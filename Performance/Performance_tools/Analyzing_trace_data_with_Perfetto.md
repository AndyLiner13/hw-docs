# Analyzing trace data with Perfetto
...
## Downloading a trace file


1. Access the performance trace files from the [Horizon Creator portal](https://horizon.meta.com/creator/performance/traces/).
2. The most recent trace is at the top of the page.
3. Select Download from the Actions menu for your trace.
...
...
# Analyzing trace data with Perfetto
...
## Downloading a trace file
...
 ![Image](https://scontent-dfw5-3.xx.fbcdn.net/v/t39.2365-6/488709489_688281970376424_8447642781732692947_n.png?_nc_cat=108&ccb=1-7&_nc_sid=e280be&_nc_ohc=4g1vCauAnLEQ7kNvwG7RXS9&_nc_oc=AdmXFkQtgkXeZ-c5Cxu-KVBjUuWHob6GCIPz2bXBq9M-m3OVa4A2-mFcUk19g0DlXlo&_nc_zt=14&_nc_ht=scontent-dfw5-3.xx&_nc_gid=MFV714RoAnMAyCXnOHfSlQ&oh=00_AfdsOMjtuFF8zeDFv7V8...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Tool controls


•  Use CTRL + mouse wheel or the w/s keys on the keyboard to zoom in and zoom out on the specific thread and event.
Use the a/d keys to pan left and right, respectively.
...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Tool controls
...
•  Use the Search input box at the top of the Prefetto UI tool to find a thread or process. ![Perfetto UI search box](https://scontent-dfw5-3.xx.fbcdn.net/v/t39.2365-6/487878008_688281963709758_2966033283031449348_n.png?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=gS1rLY9Lp1UQ7kNvwGIxDrM&_nc_oc=AdltTZTERZOicCEDMGHo3TMqOmmDa-BP0yuGbNtmuqH7FCijcfpuIYCATVc1Ma7xIlc&_nc_zt=14&_nc_ht=scontent-dfw5-3.xx&_nc_gid=MFV714RoAnMAyCX...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Tool controls
...
•  If the search function finds a match, it will highlight the counter in yellow. ![Using the Search bar to find a call inside a call graph](https://scontent-dfw5-1.xx.fbcdn.net/v/t39.2365-6/487971033_688281967043091_5021087545001880111_n.png?_nc_cat=101&ccb=1-7&_nc_sid=e280be&_nc_ohc=3Xr0MVRlHBEQ7kNvwHqS8ht&_nc_oc=AdmLiDJmMxpLWqiOS8cJxc34aENba1sMI-S0Hn91K97aEllIwWYd4PunBb9cQTZBeSc&_nc_zt=14&_nc_ht=scontent-dfw5-1.xx&_nc_g...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Tool controls
...
•  Select an event on the thread to get more information, such as:
  • Name
  • Category
  • Start time
  • Duration
  • Process ID
...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Tool controls
...
 ![Selecting a counter on the main thread, revealing the Current Selection tab](https://scontent-dfw5-1.xx.fbcdn.net/v/t39.2365-6/488185144_688281973709757_4126500563093795126_n.png?_nc_cat=101&ccb=1-7&_nc_sid=e280be&_nc_ohc=M0wj_ZAiWj4Q7kNvwFjoAwa&_nc_oc=AdnSy2oLCQaZepaSAIJxzx9bCLK8oPuJR0zHsRa0rLXtUFBclV3H4FF4NfgNlOZ4l34&_nc_zt=14&_nc_ht=scontent-dfw5-1.xx&_nc_gid=MFV714RoAnMAyCXnOHfSlQ&oh=...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
### Perfetto Tool keyboard shortcuts

 ![Image](https://scontent-dfw5-1.xx.fbcdn.net/v/t39.2365-6/452702818_512500764621213_1299181058192558473_n.png?_nc_cat=103&ccb=1-7&_nc_sid=e280be&_nc_ohc=wQQ4eV84zjYQ7kNvwE6iyfx&_nc_oc=Adk25Yed2a1y2ETN0AHUt4k8yLm9ycaDUkVhhxTbZVAmgVsVsF0xFq8MJRW8MRUxDfQ&_nc_zt=14&_nc_ht=scontent-dfw5-1.xx&_nc_gid=MFV714RoAnMAyCXnOHfSlQ&oh=00_Afd6QKE6m...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file

 To view a trace file directly from the portal, select Perfetto from the Actions menu for your trace. ![Action menu from the traces list on Horizon Creator Portal](https://scontent-dfw5-3.xx.fbcdn.net/v/t39.2365-6/488097947_688281977043090_6261626068630892822_n.png?_nc_cat=109&ccb=1-7&_nc_sid=e280be&_nc_ohc=OZ3lwSpctskQ7kNvwHoi6Xi&_nc_oc=AdlCcRDs6hMppTgTmuzJeWJThTukR_RUsrj8WkbXYYd21S3lkaM-H5Qd2HbMotWNDaM&_nc_zt=14&_nc_ht=scontent-dfw5-3.xx&_nc_gid=MFV714RoAnMAyCX...
...
# Analyzing trace data with Perfetto
...
## Viewing a trace file
...
 To load a trace from your drive, open the [Perfetto UI](https://ui.perfetto.dev/) and select Open trace file.  
### Tool controls
...
### Perfetto Tool keyboard shortcuts
 ...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns

  
#### GPU bound or CPU bound?

 It is possible for a world to appear CPU bound because it is waiting on the GPU.
If you see consistantly high wait times in `EarlyUpdate::XRUpdate` or `PlayerLoop::WaitForGFX` that could be from waiting on the GPU. It can also be caused by other reasons,
such as Particles or Additional Players. To find out, check the GPU usage where
this issue is occurring - if the GPU usage does appear high, addressing that
issue could relieve the CPU bottleneck.  
#### Rendering

 Rendering CPU usage appears as `FinishFrameRendering::PostLateUpdate` and varies depending on what is in the camera’s view. It is normal for this
call to be expensive - 2-3 milliseconds - but exceptionally high usage may mean you
need to reduce the number of Draw calls in your world.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Physics

 The Physics CPU time is tracked by `UpdateRunner:PrePhysicsUpdate`, `UpdateRunner::Physics.Simulate`, and `UpdateRunner::PostPhysicsUpdate`. Physics simulation is relatively expensive, and it is common for these
sections to total 1ms of CPU time per frame. Physics costs go up when you use complex
colliders, trigger zones, and moving objects with physics. Spikes can occur when
especially complex objects collide. Physics objects outside of the play space
also contribute to this calculation time, so we recommend you disable objects that
aren’t currently in use.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Audio

 Audio CPU time is tracked by `FMODBootstrapperService::Update` and `AudioRuntimeIntegration::Update`. If Audio CPU usage is especially high, it may mean there are too many
audio-related gizmos in the world. Typically, the Sound Recorder and Audio Graph gizmos
are more expensive than Sound Effects.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Particles

 Built-in particle updates are tracked by `ParticleSystemBeginUpdateAll::PreLateUpdate` and `ParticleSystemEndUpdateAll::PreLateUpdate`. Custom particle updates are tracked by `ParticleFxService::LateUpdate`. Use of custom particles can also create spikes in `PlayerLoop::WaitForGFX`, which will get worse when you have more particles playing at the same time.
The CPU usage is not affected by the particle effect being offscreen. To reduce
CPU usage and spikes in these areas, you may need to reduce the complexity of
particle systems or the number of systems playing at the same time in your world.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Animations

 Animation update time is tracked by `Animation::PreLateUpdate`. Especially high CPU usage in this area can mean that the world needs to reduce
the number of animations playing at once, possibly by manually turning them on
and off or by setting them to cull when offscreen. You should run some tests at
the world’s maximum capacity to determine how much additional time is required
to support your intended number of players. The `EarlyUpdate::XRUpdate` marker can be helpful with this - when a world is exceeding the target
framerate, CPU time in this area will increase to keep the framerate steady and decrease
again if more CPU time is needed elsewhere. In this way, this marker can be
used to keep track of how much unused time the world has in single-player to
accommodate additional players.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Scripting

 Scripting can impact CPU usage in a variety of ways. The `TsWorldUpdater::Update` marker covers TypeScript connected to `World.onUpdate`, the `TsWorldUpdater::PrePhysicsUpdate` marker covers TypeScript connected to `World.onPrePhysicsUpdate`, and the `ScriptingRuntimeIntegration::Update` marker covers other TypeScript calls, including networked events and async
intervals. The `Verts::Update` marker can also be relevant to this area, as many bridge calls covered in other
scripting markers will increase time in one of the `Verts::Update` sub-markers as well. Bridge calls on the server can also affect the client in
this area, so it is important to look at both when optimizing scripting. In most cases, the best place to start with scripting optimization is to reduce
bridge calls. Bridge calls are relatively expensive calls required to access or
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Scripting
...
change entity properties, including for example setting a visibility, playing a
sound, or checking a position. These calls will only appear in a Deep trace, and
it is recommended to use this setting when profiling scripts. We recommend the
following:
•  Don’t run code that isn’t needed - a player’s inventory menu doesn’t need to
update UI when it’s closed, for example, and an unspawned enemy doesn’t need to
search for the player. Disconnect functions in situations like these, or exit them
early if needed conditions aren’t met.
•  Don’t update entities that haven’t changed - a scoreboard UI may only change
when a player scores, for example, and a targeting reticle’s color may only change
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Scripting
...
when the target changes. Use events instead of `World.onUpdate` in situations like these, or store the relevant property in a variable and only
apply it to the entity when the variable doesn’t match the new state.
•  Don’t access entity states that haven’t changed - an entity’s owner does not
need to be retrieved every frame, for example, and a UI popup’s visibility may
change only rarely. In cases like these, update a variable whenever the entity
property gets changed and access that variable wherever the property is needed
instead.
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns
...
#### Additional players

 Additional players in a world can add to CPU time in a number of ways. The CPU
increase for additional avatars is most notable in `HorizonAvatarManagerUpdateRunner::Update`. Additional players can also impact CPU time in areas such as rendering,
physics, and scripting, depending on what the players are doing.  
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
### Common CPU Concerns

  
#### GPU bound or CPU bound?
...
#### Rendering
...
#### Physics
...
#### Audio
...
#### Particles
...
#### Animations
...
#### Scripting
...
#### Additional players
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread

 Depending on how you record a trace, the process name and main thread name will
vary. It might be called Process followed by a number, or TogetherServer, or
com.facebook.horizon. The main thread will be called UnityMain, or Thread followed
by a number. In any case, it should be the first process and thread you see in
the Perfetto UI. You can zoom into the thread to see the different calls being made on the main
thread. By default, press `W` on your keyboard to zoom in, and `S` to zoom out. Use `A` and `D` to pan left and right, respectively. If you use your left mouse button to drag across a frame in the main thread, you
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
can get more information from the Area Selection dialog at the bottom of the screen. If you select Slices, you can see the frame time under “Wall duration (ms)”. You can scroll down for
a list of all the calls made during the selected time. The next column, “Avg
Wall duration (ms)” will show you the average frame time across the whole trace. A
trace taken with the Deep setting will give more inflated CPU times (around 5%)
but you will have access to more detailed markers. A trace taken with the
Overview setting will have more accurate CPU times but fewer markers will be
...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
captured. Here is an example selection: ![Selecting a frame to view the slice durations](https://scontent-dfw5-2.xx.fbcdn.net/v/t39.2365-6/488666923_688281960376425_3834413545093838867_n.png?_nc_cat=102&ccb=1-7&_nc_sid=e280be&_nc_ohc=wJUf8LKWFqIQ7kNvwFjV-rQ&_nc_oc=AdmjdsnJTYR9doLS73TQGDTOdFm1acI8Rxf4xiSIBBa6AbYK2oaed7m4WGru06y8eCc&_nc_zt=14&_nc_ht=scontent-dfw5-2.xx&_nc_gid=MFV714RoAnMAyCXnOHfSlQ&oh=00_A...
...
# Analyzing trace data with Perfetto
...
## Examining the main thread
...
 When you zoom into a single frame on the thread, you can get a better
understanding of how the time is being spent. For example, while the `PlayerLoop::Update` call seems very large, it is made up of a lot of calls that vary in size. Even
if a single marker is large, that may not be an area of concern. For example, it
is normal for `HorizonAvatarManagerUpdateRunner::Update` to take 1.5ms.  
### Common CPU Concerns
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### CPU

 These counters are related to CPU usage:
|  |
|  |
| Process or UnityMain | The main thread for the world. |
| Thread or Thread Pool Wor | A worker thread for the main thread. |
| IL2CPP Thread Pool worker | Call graph for a function that converts .NET script to native. |
| TaskManager::BackgroundThread | Call graph for main background thread. |
| AppSpaceWarp | Frame Budget Boost must be enabled for ASW to adaptively turn on. A value of 0 means ASW is off, a value of 1 means AWS is on. When ASW is on, the number of milliseconds of work your world can do per-frame is nearly doubled. |
| ClientSpawn | Call graph of a new client asset being spawned. |
| ClientDespawn | Call graph of a client asset being despawned. |
| ServerSpawn | Call graph of server spawns. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### CPU
...
| PerfThrottle | Call graph of performance throttling, which prevents headlock (freezes and stutters). |
| PlayerLoop::FrameExcludePhaseSync | Call graph and frame duration excluding the player loop update. |
| PlayerLoop::PhaseSync | Call graph and duration when the player loop is updated. Phase sync time is a buffer that shrinks or expands to accommodate CPU load. As CPU time gets longer and closer to the target time to hit 72 FPS (13.8 milliseconds by default, higher if Application Space Warp is on), phase sync time gets shorter. A consistent and long phase sync time means your world is performing well and is able to generate frames faster than the device’s FPS. A phase sync time of 0 ms may indicate your world is running below 72 FPS. |
| Hardware::Cpu::UtilizationAverage | CPU average utilization, as a percentage. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### CPU
...
| Hardware::Mem::AndroidPSS | Memory used, in bytes (proportional set size). |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### GPU

 These counters are related to raw GPU rendering:
|  |
|  |
| FPS | Frames per second on the client. |
| Hardware::GPU::Time | GPU time spent, in nanoseconds |
| Hardware::GPU::Utilization | GPU utilization as a percentage |
| Hardware::GPU::DrawCalls | Number of GPU draw calls. |
| Hardware::GPU::SetPass | Number of GPU shader passes. |
| Hardware::GPU::Vertices | Number of vertices processed in draw calls. |

 These counters are related to the World Builder:
|  |
|  |
| WBSceneGraphSnapshotDeserializer::DeserializeFromBinary | Call graph when scenes are deserialized into World Builder. |
| WBStandaloneAssetService::LoadedMeshCount | Number of loaded meshes in the World Builder. |
| WBStandaloneAssetService::LoadedMeshLODCount | Number of level-of-detail settings in each mesh times number of loaded meshes. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### GPU
...
| WBStandaloneAssetService::LoadedMeshSize | Size of loaded meshes, in bytes. |
| WBStandaloneAssetService::LoadedMeshTriangleCount | Number of triangles in loaded meshes |
| WBStandaloneAssetService::LoadedMeshVertexCount | Number of vertices in loaded meshes. |
| WBStandaloneAssetService::LoadedSkydomeCount | Number of loaded skydome assets. |
| WBStandaloneAssetService::LoadedTextureCount | Number of loaded textures in the World Builder. |
| WBStandaloneAssetService::LoadedTextureSize | Size of loaded textures, in bytes. |

 These counters are related to RenderToolkit, the Horizon Worlds lighting
solution:
|  |
|  |
| RTK::TotalChunkMemoryKB | Total memory allocated for emitters and receivers, in kilobytes. |
| RTK::TotalEmitterChunkCount | Number of emitter chunks allocated. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### GPU
...
| RTK::TotalReceiverChunkCount | Number of receiver chunks allocated. |
| RTK::UsedChunkMemoryKB | Memory used by emitters and receivers, in kilobytes. |
| RTK::UsedEmitterChunkCount | Number of emitter chunks used. |
| RTK::UsedReceiverChunkCount | Number of reciever chunks used. |

 This counter is related to particle simulation:
|  |
|  |
| PKFxSimulationUpdate | Call graph of particle simulation updates |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### UI

 These counters are related to [Custom UI elements](https://developers.meta.com/horizon-worlds/learn/documentation/desktop-editor/custom-ui/performance-metrics-for-custom-ui) in the world:
|  |
|  |
| CustomUI::TotalBinding::Count | Number of UI bindings. |
| CustomUI::TotalBinding::KB | Memory used by UI bindings, in kilobytes. |
| CustomUI::TotalUI::Count | Number of visible UI objects. |
| CustomUI::UpdateBinding::Count | Number of UI updates per frame. |

 These counters are related to ReactVR, the UI library for Horizon Worlds:
|  |
|  |
| ReactVR::JsVMHeapNumCollections | The number of garbage collections in the JavaScript virtual machine heap. |
| ReactVR::JsVMHeapSize | The size of the JavaScript virtual machine heap. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### UI
...
| ReactVR::JsVMHeapTotalSize | The size of the JavaScript virtual machine heap, including uncollected objects. |
| ReactVR::Panel::Render:: CustomUIMainPanelWithoutInteraction | CPU cost for rendering CustomUIMainPanelWithoutInteraction. |
| ReactVR::Panel::Render:: DrawCalls::CustomUIMainPanelWithoutInteraction | Number of draw calls for CustomUIMainPanelWithoutInteraction. |
| ReactVR::Panel::Render:: DrawCalls::HorizonXScreenCreationToolsRootUI | Number of draw calls for HorizonXScreenCreationToolsRootUI. |
| ReactVR::Panel::Render:: DrawCalls::XScreenTravelPanel | Number of draw calls for XScreenTravelPanel. |
| ReactVR::Panel::Render:: HorizonXScreenCreationToolsRootUI | CPU cost for rendering HorizonXScreenCreationToolsRootUI. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### UI
...
| ReactVR::Panel::Render::Redraws:: CustomUIMainPanelWithoutInteraction | Number of redraws for CustomUIMainPanelWithoutInteraction. |
| ReactVR::Panel::Render::Redraws:: HorizonXScreenCreationToolsRootUI | Number of redraws for HorizonXScreenCreationToolsRootUI. |
| ReactVR::Panel::Render::Redraws:: XScreenTravelPanel | Number of redraws for XScreenTravelPanel. |
| ReactVR::Panel::Render:: XScreenTravelPanel | CPU cost for rendering XScreenTravelPanel. |
| ReactVR::RedrawsPerSec | The rendered frame rate for ReactVR. |
| ReactVR::TotalRedraws | Total number of redraws. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Audio

 These counters are related to the [audio](https://developers.meta.com/horizon-worlds/learn/documentation/typescript/api-references-and-examples/audio-apis) runtime:
|  |
|  |
| AudioRuntime::FMODAllocatedKB | The amount of memory used by the audio runtime, by 1000 bytes. |
| AudioRuntime::GetMicSamples | The number of samples in the microphone buffer. |

 These counters are related to Voice-over-IP:
|  |
|  |
| VoipServiceUpdate | Call graph for VoipServiceUpdate thread. |
| VoipThreadedMic | Microphone input events |
| Voip::Playback::BufferDepth | Number of seconds remaining in the buffer. |
| Voip::Playback::BufferOverflow | Number of samples that arrived in a burst, overflowing the buffer. |
| Voip::Playback::Energy | Audio energy in the output buffer. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Audio
...
| Voip::Playback::Starvation | Calls dropped due to resource or network issues. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Networking

 These counters are related to network traffic:
|  |
|  |
| NuVerts::NumBytesReceived | Number of bytes received over the network. |
| NuVerts::NumBytesSent | Number of bytes sent over the network. |
| NuVerts::RttEstimate | Network latency in milliseconds. |
| NuVerts::StateSyncRttEstimate | Estimated round-trip time to sync network state, in milliseconds. |
| VertsPollDriver | Call graph for function that updates entites based on network traffic. |

  
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Player

 These counters are related to the [Avatar](https://developers.meta.com/horizon-worlds/learn/documentation/desktop-editor/npcs/scripted-avatar-npcs/getting-started-with-scripted-avatar-npcs) SDK:
|  |
|  |
| AvatarSDK::LocalAvatarAnimDelayTicks | Local avatar update delay, in ticks. |
| AvatarSDK::LocalAvatarAnimMaxDelayTicks | Local avatar maximum update delay, in ticks. |
| AvatarSDK::LocalAvatarAverageLodSelected_x10 | Average local avatar level of detail selected, times 10. |
| AvatarSDK::NumActiveLocalAvatars | Count of active local (player) avatars. |
| AvatarSDK::NumActiveRemoteAvatars | Count of active remote (player) avatars. |

 These counters are related to avatar locomotion. They are all binary, 1 or 0.
|  |
|  |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Player
...
| CharacterMovementSpeedStateFast_Activations | 1 if the character is moving fast. |
| CharacterStateEmpty_Activations | 1 if the character state is empty. |
| CharacterStateGrounded_Activations | 1 if the character is touching the ground. |
| CharacterStateMotionless_Activations | 1 if the character is motionless. |
| CharacterStateMoving_Activations | 1 if the character is moving. |
| CharacterStateReady_Activations | 1 if the character is ready. |
| CharacterStateRelaxed_Activations | 1 if the character is relaxed. |
| CharacterStateSprintCooldown_Activations | 1 if the character is in a sprint cooldown. |
| CharacterStateUseEquippedItem_Activations | 1 if the character is using an equipped item. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Player
...
| OnlyLeftFootDown | 1 if the player’s left foot is down. |
| OnlyRightFootDown | 1 if the player’s right foot is down. |

 These counters measure the performance of the LocalPlayerGroundSurfaceService:
|  |
|  |
| LocalPlayerGroundSurfaceService::CacheHit | Number of times the player position relative to ground was within the cache time. |
| LocalPlayerGroundSurfaceService::CacheMiss | Number of times the player position relative to ground was recomputed. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Scripting

 These counters are related to the [Typescript](https://developers.meta.com/horizon-worlds/learn/documentation/typescript/typescript) scripts in the world:
|  |
|  |
| RuntimePerfLogging::SnapshotSamplerCount | Number of snapshot samplers processed. |
| ScriptMessage::Actions | Number of TypeScript actions processed. |
| ScriptMessage::Events | Number of TypeScript events processed. |
| ScriptingUsageLoggingService::LogSnapshot | Time spent logging snapshots of Typescript activity. |

  
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Tracing

 These counters are telemetry for the tracing system itself:
|  |
|  |
| Tracing::EventCount | Number of active tracing events. |
| Tracing::NativeFlushingTask | Call graph showing time spent flushing a native API call. |
| Tracing::SamplerAvgOverheadNs | Average sampler overhead, in nanoseconds. |
| Tracing::SamplerCount | Number of counters running this frame. |

  
### Unity

 These counters are related to the Unity engine:
|  |
|  |
| UnityAssetBundle::InstantiateFromBundle | Call graph when assets are instantiated. |
| UnityAssetBundle::PendingInstantiateCount | Number of pending instantiations of Unity assets. |
| UnityRuntimeInstantiator::AddSceneEntityAsync | Call graph when entities are added to a scene. |

  
...
...
# Analyzing trace data with Perfetto
...
## Examining counters

 In Perfetto, beneath the main thread is a series of counters captured in the
trace. These counters cover multiple subsystems including CPU, GPU, network,
scripting, and more. Some of these counters are numbers, and a few will be call graphs
similar to what you can see in the main thread. Here you will find brief
descriptions of those counters.  
### CPU
...
### GPU
...
### UI
...
### Audio
...
### Networking
...
### Player
...
### Scripting
...
### Tracing
...
### Unity
...
### Miscellaneous
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Miscellaneous

 These counters are related to troubleshooting multiple subsystems:
|  |
|  |
| batch_memory_alloc_kb | Total size of allocated SubD BatchManager GPU buffers (in kb). |
| batch_updates | Number of SubD batch updates consumed by the main thread. |
| gi_full_calc_duration_ms | Duration of full GI calculations (i.e., on world load or static geo edit). |
| gi_full_calc_millisec_per_sample | Cost per sample point of full GI calculations (i.e., on world load or static geo edit). |
| gi_init_calc_duration_ms | Duration of the initial GI calculation, upon world load. |
| gi_partial_calc_duration_ms | Duration of partial GI calculations (i.e., due to finer tessellation). |
| gi_partial_calc_microsec_per_sample | Cost per sample point of partial GI calculations (i.e., due to finer tessellation). |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Miscellaneous
...
| gi_thread_updates | Number of GI thread mesh updates (i.e., due to solves/tessellation) per sec. |
| gi_to_main_queue | Number of elements in GI thread to main thread queue. |
| input_mesh_quads | Number of quads in the input meshes. |
| input_positions_vertices | Number of vertices for input meshes. |
| main_to_gi_queue | Number of elements in main thread to GI thread queue. |
| num_active_particles | Number of active (playing/looping) particles scene. |
| num_batches_rendering | Number of SubD batches currently rendering. |
| num_groups | Number of groups managed by the batching system. |
| num_invisible_groups | Number of groups managed by the batching system containing 0 visible primatives. |
| num_light_probes | Total number of light probes. |
| num_particles | Number of particles in the scene. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Miscellaneous
...
| num_rendertoolkit_mem_errors | Number of RenderToolkit memory errors. |
| num_texture_arrays | Total number of texture arrays. |
| num_texture_slices | Total number of texture slices. |
| pct_batches_group | Percentage of rendering batches containing groups of objects that move together. |
| pct_batches_group_ppp | Percentage of rendering batches containing groups of objects that move together in per-primitive props mode. |
| pct_batches_ppp | Percentage of rendering batches in per-primitive props mode. |
| pct_batches_standard | Percentage of rendering batches without per-prim props or groups; most performant. |
| subd_global_mem_kb | Subdivision Surfaces Global Memory (in kb). |
| subd_tess_vertices_k | Subdivision Surfaces Tessellated Vertices (in K). |
| surface_count | Static and dynamic Subdivision Surfaces input mesh count. |
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Miscellaneous
...
| tess_verts_per_sec | Tessellation rate in vertices per second. |
| textures_mem_mb | Total size of allocated textures (in mb). |

    ![Nav Logo](https://static.xx.fbcdn.net/rsrc.php/yE/r/3SoBlk8EqOQ.svg)


[Facebook](https://www.facebook.com/MetaHorizon/)
[Threads](https://www.threads.com/@metahorizon)
[X](https://x.com/MetaHorizon)
[Instagram](https://www.instagram.com/metahorizon/)
[YouTube](https://www.youtube.com/@MetaQuestVR)

 Learn
[Documentation](https://developers.meta.com/horizon-worlds/learn/documentation/)
[Blog](https://developers.meta.com/horizon/blog/)
[Forum](https://communityforums.atmeta.com/t5/Creator-Forum/ct-p/Meta_Horizon_Creator_Forums)

 Programs
...
...
# Analyzing trace data with Perfetto
...
## Examining counters
...
### Miscellaneous
...
[Meta Horizon Creator Program](https://developers.meta.com/horizon-worlds/programs/)

 My Creations
[My Worlds](https://horizon.meta.com/creator/worlds_all/?utm_source=horizon_worlds_creator)
[My Assets](https://horizon.meta.com/creator/assets/?utm_source=horizon_worlds_creator)
[Performance](https://horizon.meta.com/creator/performance/traces/?utm_source=horizon_worlds_creator)

 Privacy & Legal
[Privacy Policy](https://www.meta.com/legal/privacy-policy/)
[Legal](https://www.meta.com/legal/supplemental-terms-of-service/)

 © 2025 Meta
...
...
# Analyzing trace data with Perfetto
...
## Additional Links
- [Meta home](https://developers.meta.com/horizon-worlds/)
- [Login](https://developers.meta.com/login/?redirect_uri=https%3A%2F%2Fdevelopers.meta.com%2Fhorizon-worlds%2Flearn%2Fdocumentation%2Fperformance-best-practices-and-tooling%2Fperformance-tools%2Fanalyzing-trace-data-with-perfetto%2F)
...
# Analyzing trace data with Perfetto

 In another article, you learned [how to capture a trace](https://developers.meta.com/horizon-worlds/learn/documentation/performance-best-practices-and-tooling/performance-tools/tracing/) using the Utilities menu found on your wearable. Taking it one step further,
this guide will help you understand where to find those traces and how to get the
most out of the information you’ve captured. We’ve also include a handy guide to
Perfetto Tool Keyboard shortcuts that you can reference while working within [Perfetto](https://ui.perfetto.dev/). By the end of this user guide, you’ll know how to:
• Download a trace file
• View a trace file
• Control how you see traces
• Examine the main thread
• Examine common counters

 As you get more familiar with Perfetto and the Real-time Metrics menu, reference
this checklist to better understand the cause and effect of performance issues.
...
...
# Analyzing trace data with Perfetto
...
For a more in-depth explanation and step-by-step tutorial on how to use this
...
...
# Analyzing trace data with Perfetto
...
checklist, go watch the [Connect ‘23 Horizon World Performance Optimization Best Practices talk](https://developers.meta.com/horizon-worlds/learn/documentation/performance-best-practices-and-tooling/connect-23-video-series-world-optimization-best-practices). ![Image](https://scontent-dfw5-1.xx.fbcdn.net/v/t39.2365-6/452392375_512500747954548_2104090671995035942_n.png?_nc_cat=110&ccb=1-7&_nc_sid=e280be&_nc_ohc=pueGgUqtk8gQ7kNvwFvbRmm&_nc_oc=AdmFKtaP0m3cEbipbS5n8MTWl_CbGilZhmV1O6EXRMp7gpkvzxoHSmyAHSFWa0fydm0&_nc_zt=14&_nc_ht=sconte...
...
# Analyzing trace data with Perfetto
...
 The first step in analyzing traces is downloading them once they’ve been
captured.  
## Downloading a trace file
...
## Viewing a trace file
...
## Examining the main thread
...
## Examining counters
...
## Additional Links
...
      Learn
# Analyzing trace data with Perfetto
