# CoPilot Pitfalls for Horizon Worlds Scripting

This document provides reference material for GitHub Copilot to understand common pitfalls and critical requirements when writing TypeScript scripts for Meta Horizon Worlds. These are the most frequent issues encountered during script development.

---

## üìÇ File Organization & Structure

### ‚úÖ CRITICAL: All Scripts Must Go in Root Directory

**The `scripts` directory is the ONLY location where TypeScript script files can be placed.**

- ‚úÖ **CORRECT:** `c:\Users\conta\AppData\LocalLow\Meta\Horizon Worlds\2006158430195339\scripts\MyScript.ts`
- ‚ùå **INCORRECT:** `c:\Users\conta\AppData\LocalLow\Meta\Horizon Worlds\2006158430195339\scripts\managers\MyScript.ts`
- ‚ùå **INCORRECT:** `c:\Users\conta\AppData\LocalLow\Meta\Horizon Worlds\2006158430195339\scripts\utils\MyScript.ts`

**Why:** Horizon Worlds uses a file-backed script system that expects all scripts to be in the root `scripts` directory. The Desktop Editor and VR Editor can only detect and load scripts from this location. Subdirectories are NOT supported for script files.

**Exceptions:**
- The `types/` folder is special and read-only (see below)
- Reference folders like `documentation/`, `codebase_reference/`, etc. are for development reference only

---

## üö´ Cannot Edit the `types/` Folder

**The `types/` folder is READ-ONLY and auto-generated by Horizon Worlds.**

- ‚ùå **NEVER create custom files in `types/`**
- ‚ùå **NEVER edit existing files in `types/`**
- ‚ùå **NEVER move files into `types/`**

**What's in `types/`:**
- Auto-generated TypeScript type definitions (`.d.ts` files)
- Type declarations for Horizon SDK modules
- Interface definitions for system APIs

**Why it's read-only:**
These type definitions are automatically generated and managed by the Horizon Worlds system. Any manual edits will be overwritten when the type definitions are regenerated.

**If you need custom types:**
‚úÖ Create them in your root-level script files or in separate `.ts` files in the root directory:

```typescript
// CustomTypes.ts (in root directory)
export interface MyCustomType {
  id: string;
  value: number;
}

export enum MyCustomEnum {
  Option1,
  Option2,
  Option3
}
```

---

## üì¶ Import Restrictions

### ‚ùå Cannot Import from Subdirectories

**You CANNOT import TypeScript files from folders/subdirectories.**

```typescript
// ‚ùå INCORRECT - Will fail
import { MyUtil } from "./utils/MyUtil";
import { MyManager } from "./managers/MyManager";
import { MyConfig } from "./config/MyConfig";
```

**Why:** Since all script files must be in the root directory, there are no subdirectories to import from. The Horizon Worlds module resolution system only looks in the root `scripts` directory.

### ‚úÖ Correct Import Pattern

All custom scripts must be in the root directory and imported with `./` prefix:

```typescript
// ‚úÖ CORRECT - Both files in root directory
import { MyUtil } from "./MyUtil";
import { MyManager } from "./MyManager";
import { MyConfig } from "./MyConfig";
```

### ‚úÖ Importing Horizon SDK Modules

Horizon SDK modules use special import paths:

```typescript
// ‚úÖ CORRECT - Horizon SDK imports
import * as hz from "horizon/core";
import { View, Text, Pressable, Image } from "horizon/ui";
import { AssetSpawner } from "horizon/asset-spawning";
```

**Common Horizon SDK modules:**
- `horizon/core` - Core APIs (Component, Entity, Player, etc.)
- `horizon/ui` - Custom UI components
- `horizon/asset-spawning` - Dynamic asset spawning
- `horizon/events` - Event system APIs
- `horizon/gameplay-tags` - Gameplay tag system

---

## ‚öôÔ∏è VS Code Configuration Requirements

### ‚úÖ CRITICAL: `.vscode/settings.json` Must Include TypeScript SDK Path

**The `.vscode/settings.json` file MUST contain the correct TypeScript SDK path:**

```json
{
  "typescript.tsdk": "./node_modules/typescript/lib"
}
```

**Why this is critical:**
- Horizon Worlds requires **TypeScript version 4.7.4** specifically
- This setting tells VS Code to use the workspace's local TypeScript installation
- Without this, VS Code may use a different TypeScript version, causing type errors
- The Horizon SDK type definitions are designed for TypeScript 4.7.4

**Full recommended `.vscode/settings.json`:**

```json
{
  "typescript.enablePromptUseWorkspaceTsdk": true,
  "typescript.tsdk": "./node_modules/typescript/lib",
  "files.exclude": {
    "**/.editor": true,
    "**/node_modules": true,
    "**/package.json": true,
    "**/package-lock.json": true,
    "**/tsconfig.json": true
  }
}
```

**What happens if this is missing:**
- ‚ùå VS Code may show incorrect type errors
- ‚ùå Autocomplete may not work properly
- ‚ùå Horizon SDK modules may show as "not found"
- ‚ùå Type checking may fail unexpectedly

---

## üìù File-Backed Scripts System

### Understanding Script Storage

Horizon Worlds uses a **file-backed scripts (FBS)** system:

- **Scripts are stored on the server**, not in the world file
- Worlds only store **references** to scripts
- All new worlds created after February 20, 2025 use FBS
- Each script has a **unique ID** used by the system

### Key Implications:

1. **Script Size Limits:**
   - Previous limit: 32 KB per script
   - FBS: Significantly higher limits for TypeScript
   - No limit on total script count

2. **Script Gizmos:**
   - Not automatically created in FBS worlds
   - Multiple entities can reference the same script
   - Updating a script updates all entities using it

3. **Dependencies:**
   - Scripts that import other scripts must ensure those scripts are already loaded
   - If `CarScript.ts` imports `UtilsScript.ts`, `UtilsScript.ts` must be referenced in the world
   - Assets won't automatically load dependency scripts

4. **Script Duplication:**
   - Duplicating a script gizmo creates a **reference** to the same script
   - To create a truly independent copy, use the Library > Duplicate function in VR
   - Same-name scripts with different IDs will cause warnings

---

## üéØ Common Scripting Pitfalls

### 1. Execution Mode Configuration

**Always specify execution mode correctly:**

```typescript
// Server-side (authoritative) script
export class MyServerScript extends hz.Component<typeof MyServerScript> {
  static propsDefinition = {
    // Props...
  };
  
  preStart() {
    // This runs on the server
    logWithTimestamp("Script owner: " + (this.entity.owner.get()?.name.get() ?? "NONE"));
    logWithTimestamp("Execution mode: SERVER/DEFAULT");
  }
}
```

```typescript
// Local (client-side) script
export class MyLocalScript extends hz.Component<typeof MyLocalScript> {
  static propsDefinition = {
    // Props...
  };
  
  preStart() {
    // This runs on each client
    logWithTimestamp("Script owner: " + (this.entity.owner.get()?.name.get() ?? "NONE"));
    logWithTimestamp("Execution mode: LOCAL");
  }
}
```

**In Desktop Editor:**
- Set execution mode in the Script component properties
- Options: "Default" (server), "Local" (client)
- Incorrect mode = script won't work as expected

### 2. Network Event Serialization

**Network events require SerializableState types:**

```typescript
// ‚ùå INCORRECT - Interfaces not allowed
interface MyPayload {
  value: number;
}
this.sendNetworkEvent(this.myEvent, { value: 123 } as MyPayload);

// ‚úÖ CORRECT - Inline object types
this.sendNetworkEvent(this.myEvent, { value: 123 });
```

### 3. Persistence with Player Variables

**Player variables only accept primitive types and JSON strings:**

```typescript
// ‚ùå INCORRECT - Can't store objects directly
world.persistentStorage.setPlayerVariable(player, "inventory", myInventoryObject);

// ‚úÖ CORRECT - Serialize to JSON string
const jsonString = JSON.stringify(myInventoryObject);
world.persistentStorage.setPlayerVariable(player, "inventory", jsonString);

// ‚úÖ CORRECT - Deserialize when reading
const jsonString = world.persistentStorage.getPlayerVariable(player, "inventory");
if (typeof jsonString === "string") {
  const myInventoryObject = JSON.parse(jsonString);
}
```

### 4. Custom UI Import Errors

**Use correct Custom UI component names:**

```typescript
// ‚ùå INCORRECT - These don't exist
import { Button, Column, Row, Container } from "horizon/ui";

// ‚úÖ CORRECT - Actual Custom UI components
import { View, Text, Pressable, Image, UIComponent } from "horizon/ui";
```

### 5. Event Listener Pitfalls

**Some event types don't exist in Horizon SDK:**

```typescript
// ‚ùå INCORRECT - OnPlayerInputAction doesn't exist
this.connectCodeBlockEvent(
  this.entity,
  hz.CodeBlockEvents.OnPlayerInputAction,
  (action) => { /* ... */ }
);

// ‚úÖ CORRECT - Use available event types
this.connectCodeBlockEvent(
  this.entity,
  hz.CodeBlockEvents.OnPlayerEnterWorld,
  (player) => { /* ... */ }
);
```

### 6. Local Events Cannot Communicate with Server Scripts

**‚ùå CRITICAL: Local events do NOT work for server-to-client or client-to-server communication.**

Local events (`this.connectLocalBroadcastEvent` / `this.sendLocalBroadcastEvent`) only work between scripts running in the **same execution context** (same client or same server). They **cannot** cross the network boundary.

```typescript
// ‚ùå INCORRECT - Local event from client to server won't work
// In LOCAL script (client-side):
export class MyLocalScript extends hz.Component<typeof MyLocalScript> {
  static propsDefinition = {
    myEvent: { type: hz.PropTypes.LocalEvent }
  };
  
  start() {
    // This will NOT reach server scripts!
    this.sendLocalBroadcastEvent(this.props.myEvent, { data: "hello" });
  }
}

// In SERVER script (server-side):
export class MyServerScript extends hz.Component<typeof MyServerScript> {
  static propsDefinition = {
    myEvent: { type: hz.PropTypes.LocalEvent }
  };
  
  start() {
    // This will NEVER receive events from the client above!
    this.connectLocalBroadcastEvent(this.props.myEvent, (data) => {
      // Never runs!
    });
  }
}
```

**‚úÖ CORRECT: Use Network Events for cross-context communication:**

```typescript
// ‚úÖ CORRECT - Network event from client to server
// In LOCAL script (client-side):
export class MyLocalScript extends hz.Component<typeof MyLocalScript> {
  static propsDefinition = {
    myNetworkEvent: { type: hz.PropTypes.NetworkEvent }
  };
  
  start() {
    // This WILL reach the server
    this.sendNetworkEvent(this.props.myNetworkEvent, { data: "hello" });
  }
}

// In SERVER script (server-side):
export class MyServerScript extends hz.Component<typeof MyServerScript> {
  static propsDefinition = {
    myNetworkEvent: { type: hz.PropTypes.NetworkEvent }
  };
  
  start() {
    // This WILL receive events from clients
    this.connectNetworkEvent(this.props.myNetworkEvent, (data, sender) => {
      console.log(`Received from ${sender.name.get()}: ${data.data}`);
    });
  }
}
```

**When to use each event type:**

| Event Type | Use Case | Example |
|------------|----------|---------|
| **LocalEvent** | Communication between scripts in the **same context** (all client-side OR all server-side) | Multiple UI components communicating, or multiple server managers coordinating |
| **NetworkEvent** | Communication **across contexts** (client ‚Üî server) | Client sending player input to server, server broadcasting game state to clients |

**Key Rules:**
- üî¥ **Local events** = Same execution context only (client-to-client OR server-to-server)
- üîµ **Network events** = Cross-context communication (client ‚Üî server)
- ‚ö†Ô∏è Using local events for server/client communication will **silently fail** - no errors, events just won't arrive

### 7. Binding RPC Cache Accumulation in Custom UI

**‚ùå CRITICAL: Bindings accumulate internal state over time, causing RPC size errors after multiple games.**

Custom UI Bindings maintain an internal key-value store that is sent in EVERY RPC call. This store grows with each `.set()` call and never clears automatically, eventually exceeding the 65KB RPC limit.

```typescript
// ‚ùå INCORRECT - Attempting to recreate bindings (breaks UI references)
class MyHUDComponent extends UIComponent {
  private myBinding = new Binding("initial value");
  
  initializeUI() {
    return Text({ text: this.myBinding });
  }
  
  onReturnToLobby() {
    // This breaks the UI! The Text component still references the OLD binding
    this.myBinding = new Binding("reset value");
  }
}

// ‚ùå INCORRECT - Just calling .set() doesn't clear internal state
class MyHUDComponent extends UIComponent {
  private myBinding = new Binding("initial value");
  
  onReturnToLobby() {
    // This doesn't clear the accumulated RPC cache
    this.myBinding.set("reset value");
  }
}

// ‚úÖ CORRECT - Toggle entity visibility to force reinitialization
class UIManager extends hz.Component<typeof UIManager> {
  reinitializePlayerUI(player: hz.Player) {
    const uiBundle = this.getPlayerUIBundle(player);
    
    // Hide the UI entity
    uiBundle.visible.set(false);
    this.setChildrenVisibility(uiBundle, false);
    
    // Wait for engine to process visibility change
    this.async.setTimeout(() => {
      // Show the UI entity (triggers initializeUI() again)
      uiBundle.visible.set(true);
      this.setChildrenVisibility(uiBundle, true);
      // All Bindings are now fresh with empty RPC caches
    }, 100);
  }
  
  private setChildrenVisibility(parent: hz.Entity, visible: boolean) {
    const children = parent.children.get();
    for (const child of children) {
      child.visible.set(visible);
      this.setChildrenVisibility(child, visible);
    }
  }
}
```

**Why:** From the Custom UI Optimization docs: *"On the local client, a binding set operation passes the entire key-value store to ReactVR. So the bigger this gets, the greater the CPU cost to perform a single binding set."*

When you call `Binding.set()`, the binding adds the new value to its internal key-value store but never removes old values. After multiple games with hundreds of binding updates, this store exceeds the 65KB RPC limit, causing errors like:

```
Error: Exception encountered running bridge method 'SetUIBinding': 
Cannot send RPC of size 66348 because length is greater than 65280
```

**Why recreating bindings doesn't work:**
When you call `initializeUI()`, it returns a UI tree with references to your Binding instances. If you later create new Binding instances and assign them to your class fields, the UI tree still references the OLD bindings. Calling `.set()` on the new bindings won't update the UI because the UI isn't listening to them.

**Why toggling visibility works:**
When a UI entity's visibility is set to `false` and then back to `true`, the Horizon engine:
1. Disposes the UI component (calls `dispose()` if implemented)
2. Calls `initializeUI()` again to rebuild the UI tree
3. Creates fresh Binding instances with empty key-value stores
4. Establishes new connections between the UI and the new bindings

**Common Symptoms:**
- RPC size errors after 2-3 rounds of gameplay
- Error mentions "SetUIBinding" or "UpdateBinding"
- Errors occur in multiple UI components simultaneously
- UI works fine initially but breaks after playing several rounds

**When to Reinitialize:**
- After each game round when returning to lobby
- When switching between major game states
- After extended gameplay sessions (every 5-10 rounds as preventive measure)

**Best Practice:**
Implement centralized UI reinitialization in your UI Manager that:
1. Listens to game state events (like `returnedToLobby`)
2. Manages all player UI bundles
3. Toggles visibility for the entire UI bundle hierarchy
4. Does this for all players simultaneously

**Performance Note:**
Toggling visibility has minimal performance impact:
- Happens once per round (not per frame)
- Only affects UI entities (not game objects)
- Much cheaper than dealing with RPC errors and broken UI

**Related Documentation:**
- `hw-docs/CustomUI_Cheat_Sheet/Custom_UI_optimization.md` - Binding performance guidance
- `hw-docs/CustomUI_Cheat_Sheet/Building_dynamic_custom_UI.md` - Binding usage patterns

---

## üìã Best Practices Checklist

Before finalizing any Horizon Worlds script, verify:

- [ ] ‚úÖ All script files are in the root `scripts` directory (not in subdirectories)
- [ ] ‚úÖ No custom files created in the `types/` folder
- [ ] ‚úÖ All imports use `./` for local scripts and `horizon/` for SDK modules
- [ ] ‚úÖ `.vscode/settings.json` includes `"typescript.tsdk": "./node_modules/typescript/lib"`
- [ ] ‚úÖ Execution mode (Default/Local) is logged in `preStart()` or `start()`
- [ ] ‚úÖ Script owner is logged for debugging
- [ ] ‚úÖ Network events use inline object types (not interfaces)
- [ ] ‚úÖ Persistence uses JSON.stringify/JSON.parse for complex data
- [ ] ‚úÖ Custom UI uses correct component names (View, Pressable, Text, Image)
- [ ] ‚úÖ Only using event types that exist in the Horizon SDK
- [ ] ‚úÖ UI components reinitialize via visibility toggle (not binding recreation) to clear RPC cache

---

## üîç Quick Reference

### Valid Import Patterns

```typescript
// ‚úÖ Horizon SDK imports
import * as hz from "horizon/core";
import { View, Text, Pressable, Image } from "horizon/ui";

// ‚úÖ Local script imports (both in root directory)
import { MyConfig } from "./MyConfig";
import { MyUtils } from "./MyUtils";

// ‚ùå INVALID - Cannot import from subdirectories
import { MyConfig } from "./config/MyConfig";
import { MyUtils } from "./utils/MyUtils";
```

### Valid File Locations

```
scripts/                          ‚Üê Root directory (ONLY place for .ts scripts)
‚îú‚îÄ‚îÄ MyScript.ts                   ‚úÖ Valid
‚îú‚îÄ‚îÄ MyConfig.ts                   ‚úÖ Valid
‚îú‚îÄ‚îÄ MyUtils.ts                    ‚úÖ Valid
‚îú‚îÄ‚îÄ types/                        ‚ö†Ô∏è Read-only, auto-generated
‚îÇ   ‚îî‚îÄ‚îÄ *.d.ts                    ‚ùå Cannot edit
‚îú‚îÄ‚îÄ documentation/                ‚ÑπÔ∏è Reference only
‚îú‚îÄ‚îÄ codebase_reference/           ‚ÑπÔ∏è Reference only
‚îî‚îÄ‚îÄ managers/                     ‚ùå Cannot put scripts here
    ‚îî‚îÄ‚îÄ MyManager.ts              ‚ùå INVALID LOCATION
```

### Required VS Code Settings

```json
{
  "typescript.tsdk": "./node_modules/typescript/lib"
}
```

---

## üìö Additional Resources

- [File-Backed Scripts Documentation](https://developers.meta.com/horizon-worlds/learn/documentation/typescript/filebacked-scripts)
- [Importing Data with JSON](https://developers.meta.com/horizon-worlds/learn/documentation/typescript/importing-data-with-json)
- [Adding an IDE to Desktop Editor](https://developers.meta.com/horizon-worlds/learn/documentation/typescript/getting-started/adding-an-ide-to-the-desktop-editor)

---

**Remember:** When in doubt, check the documentation and verify your file structure matches the required pattern. All scripts must be in the root directory, the `types/` folder is read-only, and VS Code must be configured with the correct TypeScript SDK path.
